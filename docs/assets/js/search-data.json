{
  "0": {
    "id": "0",
    "title": "Authorization",
    "content": "Microsoft Orleans SecurityAuthorization      Overview        Simple authorization        Role-based authorization        Policy-based authorization  ",
    "url": "https://orlsec.asynchub.org//docs/authorization",
    "relUrl": "/docs/authorization"
  },
  "1": {
    "id": "1",
    "title": "Home",
    "content": "Authorization library for Microsoft OrleansThe set of security packages for Microsoft Orleans 2.0 provide the ability to use the same authorization functionality which is used in ASP.NET Core 2.0. It allows sharing SSO (Single Sign-On) server like IdentityServer4 with Orleans grain and any ASP.NET Core 2.2 application.Get started now View it on GitHubGetting startedDependenciesThere are two packages: Orleans.Security.Cluster and Orleans.Security.ClusterClient. The first is for a silo host project and the seccond for an Orleans cluster client.Quick startPlease see sample solution for more details.LicenseOrleans.Security is distributed by an MIT license.ContributingContributions are welcome, please contact via issue, email admin@asynchub.org, or any other method with the owners of this repository.",
    "url": "https://orlsec.asynchub.org//",
    "relUrl": "/"
  },
  "2": {
    "id": "2",
    "title": "Overview",
    "content": "OverviewAuthorization refers to the process that determines what a user is able to do. For example, an administrative user is allowed to create a document library, add documents, edit documents, and delete them. A non-administrative user working with the library is only authorized to read the documents.Authorization is orthogonal and independent from authentication. However, authorization requires an authentication mechanism. Authentication is the process of ascertaining who a user is. Authentication may create one or more identities for the current user.* Authorization in Microsoft Orleans is mainly the same ASP.NET Core authorization. You can read more about ASP.NET Core authorization here.",
    "url": "https://orlsec.asynchub.org//docs/authorization/overview/",
    "relUrl": "/docs/authorization/overview/"
  },
  "3": {
    "id": "3",
    "title": "Policy-based authorization",
    "content": "Policy-based authorizationAn authorization policy consists of one or more requirements. It’s registered as part of ClientBuilder.ConfigureServices and SiloHostBuilder.ConfigureServices, in the AddOrleansClusterAuthorization method:.ConfigureServices(services =&amp;gt;{    services.AddOrleansClusterAuthorization(options =&amp;gt;    {        options.AddPolicy(&quot;AdminPolicy&quot;, policy=&amp;gt; policy.RequireRole(&quot;Admin&quot;));    });})In the preceding example, an “AdminPolicy” policy is created.Policies are applied by using the [Authorize] attribute with the policy name. For example:[Authorize(Policy = &quot;AdminPolicy&quot;)]public interface IUserGrain : IGrainWithStringKey{    Task&amp;lt;string&amp;gt; DoSomething();}RequirementsAn authorization requirement is a collection of data parameters that a policy can use to evaluate the current user/client principal. In our “EmailVerified” policy, the requirement is a single parameter—the email verified. A requirement implements IAuthorizationRequirement, which is an empty marker interface. A parameterized email verified requirement could be implemented as follows:using DomDaniel.InCloud.OrleansCluster.Security.Authorization;public class EmailVerifiedRequirement : IAuthorizationRequirement{    public bool IsEmailVerified { get; private set; }    public EmailVerifiedRequirement(bool isEmailVerified)    {        IsEmailVerified = isEmailVerified;    }}Note: a requirement doesn’t need to have data or properties.Authorization handlersAn authorization handler is responsible for the evaluation of a requirement’s properties. The authorization handler evaluates the requirements against a provided AuthorizationHandlerContext to determine if access is allowed.A requirement can have multiple handlers. A handler may inherit AuthorizationHandler&amp;lt;TRequirement&amp;gt;, where TRequirement is the requirement to be handled. Alternatively, a handler may implement IAuthorizationHandler to handle more than one type of requirement.Use a handler for one requirementThe following is an example of a one-to-one relationship in which a email verified handler utilizes a single requirement:public class EmailVerifiedHandler : AuthorizationHandler&amp;lt;EmailVerifiedRequirement&amp;gt;{    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,         EmailVerifiedRequirement requirement)    {        if (context.User.HasClaim(c =&amp;gt; c.Type == JwtClaimTypes.EmailVerified))        {            var claim = context.User.FindFirst(c =&amp;gt; c.Type == JwtClaimTypes.EmailVerified);            var isEmailVerified = Convert.ToBoolean(claim.Value);            if (isEmailVerified)            {                context.Succeed(requirement);            }        }        return Task.CompletedTask;    }}The preceding code determines if the current user/client principal has an EmailVerified claim. Authorization can’t occur when the claim is missing, in which case a completed task is returned. When a claim is present, the email verified flag is checked. If the user meets the minimum age defined by the requirement, authorization is deemed successful. When authorization is successful, context. Succeed is invoked with the satisfied requirement as its sole parameter.Use a handler for multiple requirementsThe following is an example of a one-to-many relationship in which a permission handler utilizes two requirements:public class GenderRequirement : IAuthorizationRequirement{    public string Gender { get; private set; }    public GenderRequirement(string gender)    {        Gender = gender;    }}public class RoleIsPresentRequirement : IAuthorizationRequirement{    public string Role { get; private set; }    public RoleIsPresentRequirement(string role)    {        Role = role;    }}public class RoleAndGenderCombinationHandler : IAuthorizationHandler{    public Task HandleAsync(AuthorizationHandlerContext context)    {        var pendingRequirements = context.PendingRequirements.ToList();        foreach (var requirement in pendingRequirements)        {            switch (requirement)            {                case RoleIsPresentRequirement roleIsPresentRequirement:                {                    if (context.User.IsInRole(roleIsPresentRequirement.Role))                    {                        context.Succeed(roleIsPresentRequirement);                    }                    break;                }                case GenderRequirement genderRequirement:                {                    if (context.User.HasClaim(c =&amp;gt; c.Type == JwtClaimTypes.Gender))                    {                        var claim = context.User.FindFirst(c =&amp;gt; c.Type == JwtClaimTypes.Gender)                        if (claim.Value == genderRequirement.Gender)                        {                            context.Succeed(requirement);                        }                    }                    break;                }            }        }        return Task.CompletedTask;    }}The preceding code traverses PendingRequirements—a property containing requirements not marked as successful. When authorization is successful context.Succeed is invoked with the satisfied requirement as its sole parameter.Handler registrationHandlers are registered in the services collection during configuration. For example:.ConfigureServices(services =&amp;gt;{    services.AddOrleansClusterAuthorization(options =&amp;gt;    {        options.AddPolicy(&quot;AdminPolicy&quot;, policy=&amp;gt; policy.RequireRole(&quot;Admin&quot;));    });    services.AddSingleton&amp;lt;IAuthorizationHandler, EmailVerifiedHandler&amp;gt;();    services.AddSingleton&amp;lt;IAuthorizationHandler, RoleAndGenderCombinationHandler&amp;gt;();})What should a handler return?Note that the Handle method in the handler example returns no value. How is a status of either success or failure indicated?  A handler indicates success by calling context.Succeed(IAuthorizationRequirement requirement), passing the requirement that has been successfully validated.  A handler doesn’t need to handle failures generally, as other handlers for the same requirement may succeed.  To guarantee failure, even if other requirement handlers succeed, call context.Fail.Why would I want multiple handlers for a requirement?In cases where you want evaluation to be on an OR basis, implement multiple handlers for a single requirement.For the additional information please see ASP.NET Core documentation",
    "url": "https://orlsec.asynchub.org//docs/authorization/policy-based-authorization/",
    "relUrl": "/docs/authorization/policy-based-authorization/"
  },
  "4": {
    "id": "4",
    "title": "Role-based authorization",
    "content": "Role-based authorizationWhen an identity is created it may belong to one or more roles. For example, Alice may belong to the Administrator and User roles whilst Bob may only belong to the User role. How these roles are created and managed depends on the IdentityServer4 of the authorization process.Role-based authorization checks are declarative—the developer embeds them within their code, against a grain interface or an method within a grain interface, specifying roles which the current user or client (please see IdentityServer4 terminology) must be a member of to access the requested resource.For example, the following code limits access to any methods on the implementation of IUserGrain to users/clients who are a member of the Administrator role:[Authorize(Roles = &quot;Administrator&quot;)]public interface IUserGrain : IGrainWithStringKey{    Task&amp;lt;string&amp;gt; DoSomething();    Task&amp;lt;string&amp;gt; DoSomethingElse();}You can specify multiple roles as a comma separated list:[Authorize(Roles = &quot;Administrator, Manager&quot;)]public interface IUserGrain : IGrainWithStringKey{    Task&amp;lt;string&amp;gt; DoSomething();    Task&amp;lt;string&amp;gt; DoSomethingElse();}This grain would be only accessible by users/clients who are members of the Administrator role or the Manager role.If you apply multiple attributes then an accessing user/client must be a member of all the roles specified; the following sample requires that a user must be a member of both the Developer and Manager role.[Authorize(Roles = &quot;Developer&quot;)][Authorize(Roles = &quot;Manager&quot;)]public interface IUserGrain : IGrainWithStringKey{    Task&amp;lt;string&amp;gt; DoSomething();    Task&amp;lt;string&amp;gt; DoSomethingElse();}You can further limit access by applying additional role authorization attributes at the method level:[Authorize(Roles = &quot;Developer&quot;)][Authorize(Roles = &quot;Manager&quot;)]public interface IUserGrain : IGrainWithStringKey{    Task&amp;lt;string&amp;gt; DoSomething();    [Authorize(Roles = &quot;Manager&quot;)]    Task&amp;lt;string&amp;gt; DoSomethingElse();}In the previous code snippet members of the Developer role or the Manager role can access the grain and the DoSomething method, but only members of the Manager role can access the DoSomethingElse method.You can also lock down a grain but allow anonymous, unauthenticated access to individual methods.[Authorize]public interface IUserGrain : IGrainWithStringKey{    Task&amp;lt;string&amp;gt; DoSomething();    [AllowAnonymous]    Task&amp;lt;string&amp;gt; DoSomethingElse();}",
    "url": "https://orlsec.asynchub.org//docs/authorization/role-based-authorization/",
    "relUrl": "/docs/authorization/role-based-authorization/"
  },
  "5": {
    "id": "5",
    "title": "Simple authorization",
    "content": "Simple authorization in MS Orleans clusterAuthorization in Orleans is controlled through the AuthorizeAttribute attribute and its various parameters. At its simplest, applying the AuthorizeAttribute attribute to a Grain Interface or Grain Interface Method limits access to the grain or method to any authenticated user.For example, the following code limits access to the UserGrain to any authenticated user.[Authorize]public interface IUserGrain : IGrainWithStringKey{    Task&amp;lt;string&amp;gt; DoSomething();    Task&amp;lt;string&amp;gt; DoSomethingElse();}If you want to apply authorization to a method rather than the grain, apply the AuthorizeAttribute attribute to the method itself:public interface IUserGrain : IGrainWithStringKey{    [Authorize]    Task&amp;lt;string&amp;gt; DoSomething();    Task&amp;lt;string&amp;gt; DoSomethingElse();}Now only authenticated users can access the DoSomething method and everyone can access DoSomethingElse method.You can also use the AllowAnonymous attribute to allow access by non-authenticated users to individual actions. For example:[Authorize]public interface IUserGrain : IGrainWithStringKey{    [AllowAnonymous]    Task&amp;lt;string&amp;gt; DoSomething();    Task&amp;lt;string&amp;gt; DoSomethingElse();}This would allow only authenticated users to the UserGrain, except for the DoSomething method, which is accessible by everyone, regardless of their authenticated or unauthenticated / anonymous status.Warning[AllowAnonymous] bypasses all authorization statements. If you combine [AllowAnonymous] and any [Authorize] attribute, the [Authorize] attributes are ignored. For example if you apply [AllowAnonymous] at the grain level, any [Authorize] attributes on the same grain (or on any method within it) is ignored.",
    "url": "https://orlsec.asynchub.org//docs/authorization/simple-authorization/",
    "relUrl": "/docs/authorization/simple-authorization/"
  }
}
